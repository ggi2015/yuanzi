# Algo

## OOP  
前：提纲，包括其需求；
开始时，关注每项任务的输入输出，需要做什么而不是如何去做；


## Sorting  
按特定顺序（递增、非递减、递减、非递减、lexicographical, etc）对数组（或列表）的项（可以进行比较，例如整数、浮点数、字符串等）进行重新排序。
比较算法优劣的指标：比较次数和数据移动次数；包括三种情况：最好情况（数据已排序），最坏情况（反序），平均情况（数据顺序随机）；  
1. 基本排序算法
   1. 插入排序

   2. 选择排序
   3. 冒泡排序
   4. 梳排序  
2. 决策树  
每个排序算法都可以表示成为一个弧上标有是或否的二叉树，树的非终端节电包含标记的条件或查询，叶子节点的顺序可以是应用该算法的数组的任何顺序，这种类型的树称为决策树。 
不同长度数组需要不同决策树。  



## DS  
ADT：定义了一个数据对象，各数据元素之间的关系，对数据元素的操作；
   体现了程序设计中，问题分解、抽象和信息隐藏的特性；
ADT标准格式：
```C
ADT 抽象数据类型名
Data
   数据元素之间逻辑关系的定义
Operation
   操作1
      初始条件
      操作结果描述
   操作2
      ...
   操作n
      ...
endADT
```  

## Algo
五个基本特性：输入、输出、有穷性、确定性和可行性  
   其他特性：正确、可读、健壮、高效和低存储量  

效率度量方法：  
- 事后统计  
- 事前分析  

渐进增长：n>N,f(n)>g(n),f渐进增长快于g  

关注主项（最高阶项）的阶数  

时间复杂度

一般在没有特殊说明的情况下，都是指最坏时间复杂度。  

### 线性表List
有序且有限  
```C
ADT 线性表(List)
   Data
   数据对象集合 {a1,a2,...,an};.每个元素类型均为 DataType；  
   其中，除第一个元素外，每个元素有且只有一个直接前驱元素；除最后一个元素外，每个元素有且只有一个直接后继元素；数据元素之间的关系是一对一关系；  

   Operation
   InitList (*L) : 初始化操作,建立一个空的线性表L；  
   ListEmpty (L) : 若线性表为空,返回true；否则返回false；  
   ClearList (*L) : 将线性表清空；  
   GetElem (L, i, *e) : 将线性表L中的第i个元素位置值返回给e；  
   LocateElem (L ,e) : 在线性表L中查找与给定e相等的元素,如果查找成功,返回该元素在表中序号表示成功;否则，返回0表示失败；  
   ListInsert (*L， i，e) : 在线性表L中的第i个位置插入新元素e；  
   ListDelete (*L, i, *e) : 删除线性表L中第i个位置元素,并用e返回其值；  
   ListLength (L) : 返回线性表L的元素个数；  
end ADT

```

```C
/*
* 实现两个线性表集合A和B的并集操作；把存在于B中但不存在于A中的数据元素插入到A中；  
*/
void union(List *La, List *Lb)
{
   // TODO
}
```

顺序存储结构  
一维数组实现顺序存储  
```C
//包含三个属性：存储空间起始位置；最大存储容量；当前长度；  
#define MAXSIZE 20
typedef int ElemType;
typedef  struct
{
   ElemType data[MAXSIZE];
   int length;
}SqList;
```
按地址读数据：LOC(ai)=LOC(a1)+(i-1)*c;  
c表示每个元素占用存储空间；  

随机存取结构：存取时间性能为O(1);利用地址存取数据，对每个线性表位置的存入或取出数据，对于计算机都是相同时间；  

顺序存储结构的插入与删除：
```C
Status GetElem(SqList L,int i,ElemType *e)
{
   // TODO
}

Status ListInsert(SqList *L,int i,ElemType e)
{
   // TODO
}

Status ListDelete(SqList *L,int i,ElemType *e)
{
   // TODO
}

插入和删除的时间复杂度  

优缺点  


```

线性表的链式存储结构  
结点（Node）：数据域，指针域；
头结点数据域不存信息；
c.f. 头结点和头指针；  
```C
/*
* 线性表的单链表存储结构
*/
typedef struct Node
{
   ElemType data;
   struct Node* next;
} Node;  
typedef struct Node *LinkList;
```
单链表的读取：  
```C
/*
*初始条件：顺序线性表L已存在，1<=i<=ListLength(L)
*操作结果： 用e返回L中第i个数据元素的值
*/
Status GetElem(SqList L,int i,ElemType *e)
{
   // TODO
}

/*
*初始条件：顺序线性表L已存在，1<=i<=ListLength(L)
*操作结果： 在L中第i个位置之前插入新的数据元素e，L的长度加1
*/
Status ListInsert(SqList *L,int i,ElemType e)
{
   // TODO
}

/*
*初始条件：顺序线性表L已存在，1<=i<=ListLength(L)
*操作结果： 删除L的第i个数据元素，并用e返回其值，L的长度减1
*/
Status ListDelete(SqList *L,int i,ElemType *e)
{
   // TODO
}

/*
*整表创建
*随机产生n个元素的值，建立带表头结点的单链线性表L（头插法）
*/
void CreateListHead(LinkList *L, int n)
{
   // TODO
}
（尾插法）
void CreateListTail(LinkList *L, int n)
{
   // TODO
}

/*
*整表删除
*初始条件：顺序线性表L已存在，操作结果：将L重置为空表
*/
Status ClearList(LinkList *L)
{
   // TODO
}
```

单链表结构与顺序存储结构优缺点  

静态链表：用数组描述的链表  
```C
/*
*通常把数组建立得大一些，以便有空闲空间便于插入不至于溢出
*线性表的静态链表存储结构
*第一个元素和最后一个元素不存数据，第一个游标存备用链表的第一个节点下标，最后一个游标存第一个有数值的元素的下标，相当于单链表中头结点作用;(pic/DS3-12-2.png)
*/
#define MAXSIZE 1000 //假设链表最大长度1000
typedef struct
{
   ElemType data;
   int cur; //游标，为0时表示无指向
} Component,StaticLinkList[MAXSIZE];
```  

```C
/*
*将一维数组space中各分量链成一备用链表
*spac[0].cur为头指针，“0”表示空指针
*/
Status InitList(StaticLinkList space)
{
//TODO
}
```  

```C
/*
*若备用空间链表非空，则返回分配的结点下标，否则返回0
*/
Status Malloc_SLL(StaticLinkList space)
{
//TODO
}
```   

```C
/*
*在L中第i个元素之前插入新的元素e
*/
Status ListInsert(StaticLinkList L, int i, ElemType e)
{
//TODO
}
``` 

```C
/*
*删除在L中的第i个数据元素e
*/
Status ListDelete(StaticLinkList space, int i)
{
//TODO
}
```   

```C
/*
*将下标为k的空闲结点回收到备用链表
*/
Status Free_SSL(StaticLinkList space, int k)
{
//TODO
}
```   

```C
/*
*初始条件：静态链表已存在。操作结果：返回L中数据元素个数
*/
Status ListLength(StaticLinkList L)
{
//TODO
}
```   
静态链表优缺点  

### 循环链表
将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表。  

### 双向链表  
单链表的每个结点中，在设置一个指向其前驱结点的指针域。每个结点两个指针域，一个指向直接后继，另一个指向直接前驱；  
```C
/*
*线性表的双向链表存储结构
*/
typedef struct DulNode
{
   ElemType data;
   struct DulNode *prior;  //直接前驱指针
   struct DulNode *next;   //直接后继指针
} DulNode, *DuLinkList;
```  

### 总结  
|线性表     |          |       |      |       |  
|----      |----      |----   |----  |----   |
|顺序存储结构|链式存储结构|       |      |       | 
|          |单链表     |静态链表|循环链表|双向链表|  


## 栈与队列  
栈：限定仅在表尾进行插入和删除操作的 - 线性表 -  
队列：只允许在一端进行插入操作、而在另一端进行删除操作的线性表  

### 栈
栈顶（top）：允许插入删除的一端，另一端：栈底；  
LIFO  
3个元素，5种可能的出栈次序；  

```C
ADT Stack
Data
    元素具有相同的类型，相邻元素具有前驱和后继关系
Operation
   InitStack(*S):初始化操作，建立一个空栈S。
   DestroyStack(*S):若栈存在，则销毁它。
   ClearStack(*S):将栈清空。
   StackEmpty(S):若栈为空，返回true， 否则返回false。
   GetTop(S, *e):若栈存在且非空，用e返回S的栈顶元素。
   Push(*S, e):若栈S存在，插入新元素e到栈S中并成为栈顶元素。
   Pop(*S, *e):删除栈S中栈顶元素，并用e返回其值。
   StackLength(S):返回栈S的元素个数。
endADT  
```    
#### 栈的顺序存储结构及其实现
栈空top=-1，栈满top=MAXSIZE-1 
```C
/*
*栈的结构定义
*/
typedef int SElemType; //SElemType类型根据实际情况而定，这里假设为int
typedef struct
{
   SElemType data[MAXSIZE];
   int top; //用于栈顶指针
}SqStack
```  

```C
/*
* 进栈操作，插入元素e为新的栈顶元素
*/
Status Push(SqStack *S, SElemType e)
{
   //TODO
}
```

```C
/*
* 出栈操作；若栈不为空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR
*/
Status Pop(SqStack *S, SElemType *e)
{
   //TODO
}
```
#### 两栈共享空间  
```C
/*
* 两栈共享空间结构
*/
typedef struct
{
   SElemType data[MAXSIZE];
   int top1;   //栈1栈顶指针
   int top2;   //栈2栈顶指针
}SqDoubleStack;

//插入元素e为新的栈顶元素
Status Push(SqDoubleStack *S, SElemType e, int stackNumber)
{
   //TODO
}

//若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR
Status Pop(SqDoubleStack *S, SElemType *e, int stackNumber)
{
   //TODO
}
```  

#### 栈的链式存储结构及其实现  
空栈top=NULL，基本不存在栈满  
```C
/*
*结构代码
*/
typedef struct StackNode
{
   SElemType data;
   struct StackNode *next;
}StackNode, *LinkStackPtr;

typedef struct LinkStack
{
   LinkStackPtr top;
   int count ;
}LinkStack;
```  

```C
/*
* 进栈操作，插入元素e为新的栈顶元素
*/
Status Push(LinkStack *S, SElemType e)
{
   //TODO
}
```

```C
/*
* 出栈操作；若栈不为空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR
*/
Status Pop(LinkStack *S, SElemType *e)
{
   //TODO
}
```
顺序栈/链栈的Push/Pop操作，时间复杂度均为O(1)；  
栈的使用过程中，元素变化不可预料，时大时小，最好用链栈；反之，变化在可控范围，建议顺序栈；  

#### 栈的应用
1. 递归  
斐波那契数列实现：
定义：把一个直接调用自己或者通过一系列的调用语句间接调用自己的函数，称为递归函数  
递归函数必须要有终止条件，否则陷入无尽循环

2. 四则运算表达式求值  
逆波兰表达法：所有运算符都是要在运算数字的后面出现；  
从左到右遍历表达式，遇到数字进栈，遇到符号，将处于栈顶的两个数字出栈，进行运算，结果入栈，直到最后；  

### 队列
定义：一端插入，另一端删除的线性表。FIFO  
```C
ADT Queue
Data
   元素具有相同的类型，相邻元素具有前驱和后继关系。
Operation
   InitQueue(*Q);初始化操作，建立一个空队列Q
   DestroyQueue(*Q):若队列存在，则销毁它
   ClearQueue(*Q):将对列清空
   QueueEmpty(Q):若队列Q为空，返回true，否则返回false
   GetHead(Q, *e):若队列存在且非空，用e返回队列Q的对头元素
   EnHead(*Q, e):若队列存在，插入新元素e到队列Q中并成为Q的对头元素
   DeQueue(*Q, *e):删除队列Q中对头元素，并用e返回其值
   QueueLength(Q):返回队列Q的元素个数
endADT
```
#### 循环队列  
队列顺序存储不足：对头离开，后面的人都得往前挪一步；引入front和rear指针，假溢出  
定义：头尾相接的顺序存储结构称为循环队列  
判满：设置标志位；或者当front与rear相隔一个时，我们就认为满  
通用的计算队列长度公式：**(rear-front+QueueSize)%QueueSize**  
```C
/*
*循环队列的顺序存储结构
*/
typedef int QElemType; //QElemType 类型根据实际情况而定
typedef struct
{
   QElemType data[MAXSIZE];
   int front;  //头指针
   int rear;   //尾指针，若对列不为空，指向队列尾元素的下一个位置
}SqQueue;
```
```C
/*
*初始化一个空队列Q
*/
Status InitQueue(SqQueue *Q)
{
   //TODO
}
```
```C
/*
*循环队列求队列长度，返回Q的元素个数，也就是队列的当前长度
*/
int QueueLength(SqQueue Q)
{
   //TODO
}
```
```C
/*
*循环队列入队操作，若队列未满，则插入元素e为Q新的队尾元素
*/
Status EnQueue(SqQueue *Q， QElemType e)
{
   //TODO
}
```
```C
/*
*循环队列出队操作，若对列不为空，则删除Q中对头元素，用e返回其值
*/
Status DeQueue(SqQueue *Q, QElemType *e)
{
   //TODO
}
```

#### 队列的链式存储结构及其实现  
队列的链式存储结构，其实就是线性表的单链表，只不过只能尾进头出，简称链队列  
```C
/*
*链队列结构
*/
typedef int QElemType;  //QElemType类型根据实际情况而定，这里假设为int
typedef struct QNode //结点结构
{
   QElemType data;
   struct QNode  *next;
}QNode, *QueuePtr;
typedef struct //队列的链表结构
{
   QueuePtr front, rear;   //对头、队尾指针
}LinkQueue;
```
```C
/*
*队列链式存储的入队操作，插入元素e为Q新的队尾元素
*/
Status EnQueue(LinkQueue *Q， QElemType e)
{
   //TODO
}
```
```C
/*
*队列链式存储的出队操作，若对列不为空，则删除Q中对头元素，用e返回其值，并返回OK，否则返回ERROR
*/
Status DeQueue(SqQueue *Q, QElemType *e)
{
   //TODO
}
```
循环队列与链队列基本操作都是时间常数，都为O(1);循环队列是事先申请好空间，使用期间不释放，链队列，每次申请 和释放结点存在时间开销；故若出入队频繁，两者还是有区别；但链队列无空间浪费一说；  
在队列长度最大值确定的情况下，建议循环队列；无法预估队列长度，链队列  

### 总结回顾
|栈  |队列  |
|--- |---  |
|顺序栈|顺序队列|
|- 两栈共享空间|- 循环队列|
|链栈 |链队列|



## String
串（String）：由零个或多个字符组成的有限序列，又叫字符串。  
一般记为：s="a1a2...an"(n>=0)  

### 串的比较  
给定两个串：s="a1a2...an",t="b1b2..bm" ，当满足以下条件之一，s < t:  
1. n < m， 且ai = bi (i=1,2,...,n);  
2. 存在某个k <= min(m,n)， 使得ai = bi (i=1,2,...,k-1)， ak < bk;  
注：字母大小按照ascii码来比。  

### 抽象数据类型
```C
ADT String
Data
   串中元素仅由一个字符组成，相邻元素具有前驱和后继关系
Operation
   StrAssign(T, *chars)   //生成一个其值等于字符串常量chars的串T；
   StrCopy(T, S)   //串S存在， 由串S复制得串T；
   ClearString(S) //串S存在，则将串清空；
   StringEmpty(S) //若串S为空，返回true，否则返回false；
   StrLength(S)    //返回串S的元素个数，即串的长度；
   StrCompare(S, T)   //若S > T， 返回值 > 0, 若 S = T， 返回0，若S < T, 返回值 < 0;
   Concat(T, S1, S2)  //用T返回由S1和S2连接而成的新串；
   SubString(Sub, S, pos, len)    //串S存在，1<=pos<=StrLength(S), 且0<=len<=StrLength(S)-pos+1， 用Sub返回串S的第pos个字符起长度为len的子串；
   Index(S, T, pos)  //串S和T存在，T是非空串，1<=pos<=StrLength(S)。若主串S中存在和串T值相同的子串，则返回它在主串S中第pos个字符之后第一次出现的位置，否则返回0；
   Replace(S, T, V)  //串S和T存在，T是非空串。用V替换主串S中出现的所有与I相等的不重叠的子串；
   StrInsert(S, pos, T) //串S和T存在，1<=pos<=StrLength(S)+1。在串S的第pos个字符之前插入串T；
   StrDelete（S, pos, len) //串S存在，1<=pos<=StrLength(S)-len+1。从串S中删除第pos个字符起长度为len的子串。
endADT
```

### 串的存储结构
- 顺序存储结构

- 链式存储结构

### 模式匹配算法
- 朴素模式匹配   
主串作大循环，每个字母都与子串尝试匹配

- KMP模式匹配  


## Tree
树(Tree)是n(n >= 0)个结点的有限集。n=0时，称为空树。在任意一棵非空树中：
(1) 有且仅有一个特定的称为根(Root)的结点；
(2) 当n>1时，其余结点可分为m(m>0)个互不相交的有限集T1，T2，...,Tm，其中每一个集合本身又是一棵树，称为根的子树(SubTree)。   
注：根结点唯一；m > 0时，子树个数没有限制，但之间一定互不相交。  
度(Degree)：结点拥有的子树数；  
度为0的结点称为叶结点(Leaf)或终端结点；度不为0的结点称为非终端结点或分支结点。除根结点，分支结点也称为内部结点。树的度是树内各结点的度的最大值。  
树中结点的最大层次称为树的深度(Depth)或高度。  
森林(Forsest)是m(m>=0)棵互不相交的树的集合。  
|线性结构|树结构|
|----   |---- |
|第一个数据元素：无前驱|根结点：无双亲，唯一|
最后一个数据元素：无后继|叶结点：无孩子，可以多个|
|中间元素：一个前驱一个后继|中间结点：一个双亲多个孩子|

### 树的抽象数据类型  
```C
ADT Tree
Data
   树是由一个根结点和若干棵子树构成。树中结点具有相同数据类型及层次关系。
Operation
   InitTree(*T)   //构造空树T
   DestroyTree(*T)   //销毁树T
   CreateTree(*T, Definition) //按definition中给出树的定义来构造树
   ClearTree(*T)  //若树T存在，则将树T清为空树
   TreeEmpyty(T)  //若T为空树，返回true，否则返回false
   TreeDepth(T)   //返回T的深度
   Root(T)  //返回T的根结点
   Value(T, cur_e)   //cur_e 是树T中一个结点，返回此结点的值
   Assign(T, cur_e, value) //给树T的结点cur_e赋值为value
   Parent(T,cur_e)   //若cur_e是树T的非根节点，则返回他的双亲，否则返回空
   LeftChild(T, cur_e)  //若cur_e是树的非叶节点，则返回他的最左孩子，否则返回空
   RightSibling(T, cur_e)  //若cur_e有右兄弟，则返回他的右兄弟，否则返回空
   InsertChild(*T, *p, i, c)  //其中p指向树T的某个结点，i为所指结点p的度加一，非空树c与T不相交，操作结果为插入c为树T中p指结点的第i棵子树
   DeleteChild(*T, *p, i)  //其中p指向树T的某个结点， i为所指结点p的度，操作结果为删除T中p所指结点的第i棵子树
endADT
```

### 树的存储结构
- 双亲表示法  
   从树的双亲角度  
   以一组连续空间存储树的结点，同时在每个结点中，附设一个指示器指示其双亲结点到链表中的位置。（即每个结点知道自己是谁，还知道双亲在哪儿）  
   ```C
   /*
   *树的双亲表示法结点结构定义
   */
   //TODO
   ```
   adv：  
      容易找双亲  
   dis:  
      找孩子
- 孩子表示法  
   从树的孩子的角度  
   用多重链表，即每个结点有多个指针域，其中每个指针指向一棵子树的根结点，我们把这种方法叫做多重链表表示法
   孩子表示法：把每个结点的孩子结点排列起来，以单链表作存储结构，则n个结点有n个孩子链表，如果是叶子结点则此单链表为空。然后n个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中。  
   需要两种结点结构：孩子链表的孩子结点；表头数组的表头结点。
   ```C
   /*
   *树的孩子表示法结构定义
   */
   //TODO  
   ```
   adv：  
      便于查找某个结点的某个孩子，或者某个结点的兄弟（只需查找这个结点的孩子单链表即可）  
      便于遍历整棵树（对头结点的数组循环即可）  
   dis：  
      结点双亲查找（双亲孩子表示法）

- 孩子兄弟表示法  
   从树结点的兄弟的角度  
   任意一棵树，他的结点的第一个孩子如果存在，就是唯一的，他的右兄弟如果存在也是唯一的；因此，设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟；  
   ```C
   /*
   *树的孩子兄弟表示法结构定义
   */
   //TODO
   ```
   
   ## 二叉树  
   Binary Tree是n（n>=0)个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的、分别称为根节点的左子树和右子树的二叉树组成。  
   特点：
      - 每个结点最多两棵子树，二叉树中不存在度大于2的结点。
      - 左子树和右子树有顺序，次序不能颠倒。
      - 即使某刻树中只有一棵子树，也要区分是左子树还是右子树。
   五种基本形态：  
      - 空二叉树
      - 只有一个根结点
      - 根结点只有左子树
      - 根结点只有右子树
      - 根结点既有左子树又有右子树
   特殊二叉树：  
      - 斜树：所有结点都只有左结点，左斜树；右斜树；统称为斜树；
      - 满二叉树：所有分支结点都存在左子树和右子树，且所有叶子都在同一层
         特点：  
         - 叶子只能出现在最下一层；
         - 非叶子结点度 一定是2；  
         - 同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多；  
      - 完全二叉树：对一棵具有n个结点的二叉树按层编号，如果编号为i（1 < i < n）的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则为完全二叉树；  
         满是完全；
         按层编号：从上到下，从左到右
         特点：
         - 叶子结点出现在最下两层；
         - 最下层叶子一定集中在左部连续位置；
         - 倒数第二层，若有叶子，一定在右部连续位置；
         - 如果结点度为1，则该结点只有左孩子，
         - 同样结点数的二叉树，完全二叉树深度最小；  
## 二叉树性质  
1. 第i层，最多有pow(2,i-1)个结点(i>=1)
2. 深度为k的二叉树至多有pow(2,k)-1个结点(k>=1)
3. 对任何一棵二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0=n2+1；
4. 具有n个结点的完全二叉树的深度为[floor(log2n) + 1]；
5. 如果对一棵树有n个结点的完全二叉树(其深度为[floor(log2n)+1])的结点按层序编号（从第1层到第[floor(log2n)+1]层，每层从左到右），对任一结点i(i<= i <= n)有：
   - 如果i=1，则结点i是二叉树的根，无双亲；如果i>1，则其双亲是结点[floor(i/2)];
   - 如果2i>n，则结点i无左孩子（结点i为叶子结点）；否则其左孩子是结点2i；
   - 如果2i+1>n，则结点i无右孩子；否则其右孩子是结点2i+1；[TODO]

## 二叉树的存储结构  
- 顺序存储：适用性不强
- 链式存储：
   二叉树每个结点只有两个孩子，为他设计一个数据域两个指针域，这样的链表叫二叉链表；  
   |lchild|data|rchild|
   |---   |--- |---   |
   ```C
   /*
   *二叉链表结构定义
   */
   //TODO
   ```

## 遍历二叉树
二叉树的遍历(traversing binary tree)指从根结点出发，按照某种**次序**依次**访问**二叉树中所有结点，使得每个结点被访问一次，且仅被访问一次。  
访问：需要根据实际情况确定做什么；
次序：分支处，存在结点的选择问题；  
遍历方法：   
- 前序遍历
   若二叉树为空，则空操作返回，否则先访问根结点，再前序遍历左子树，再前序遍历右子树；  
   ```C
   /*
   * 二叉树的前序遍历递归算法
   */
   void PreOrderTraverse(BiTree T)
   [TODO]
   ```  
- 中序遍历
   ，否则从根结点开始（注意并不是先访问根结点），中序遍历根结点的左子树，然后访问根结点，最后中序遍历右子树。  
   ```C
   /*
   * 二叉树的中序遍历递归算法
   */
   void InOrderTraverse(BiTree T)
   [TODO]
   ``` 
- 后序遍历  
   ，否则从左到右，先叶子后结点的方式遍历访问左右子树，最后是访问根结点。  
   ```C
   /*
   * 二叉树的后序遍历递归算法
   */
   void PostOrderTraverse(BiTree T)
   [TODO]
   ``` 
- 层序遍历
   ，否则从树的

### 推导遍历的结果  
[TODO]

## 二叉树的建立  
将二叉树中每个结点的空指针引出一个虚结点，其值为一特定值`#`，称处理后的二叉树为原二叉树的扩展二叉树。扩展二叉树可以做到一个遍历序列确定一棵二叉树。  
```C
/*
* 按前序输入二叉树中的结点的值（一个字符）
* #表示空树，构造二叉链表表示二叉树T
*/
void CreateBiTree(BiTree *T)
{
   [TODO]
}
```

## 线索二叉树 
指向前驱和后继的 指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树就称为线索二叉树（Threaded Binary Tree）。  
对某种二叉树以某种次序遍历，使其成为线索二叉树的过程称为线索化。
- 线索二叉树的实现  
```C
/*
* 二叉树的二叉线索存储结构定义
*/
[TODO]
```  

## 树、森林与二叉树的转换  
- 树转化为二叉树  
- 森林转化为二叉树  
- 二叉树转化为树  
- 二叉树转换为森林  
- 树与森林的遍历

## 霍夫曼树及其应用  
压缩编码技术——霍夫曼编码  

### 霍夫曼树定义与原理  
[TODO]

# 图  
图（Graph）是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为G(V,E)，其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。  

## 定义  
线性表中数据元素——元素；树中数据元素——结点；图中数据元素——顶点(Vertex);  
在图中，不允许没有顶点，G中V有穷非空；  
图中，任意两个顶点都可能有关系，顶点之间逻辑关系通过边表示；  
- 无向边：若顶点vi到vj之间没有方向，则称这条边为无向边(Edge)，用无序偶对(vi,vj)来表示。  
   无向图：图中任意两个顶点之间的边都是无向边的图；   
- 有向边：                有方向，           有向边，或称弧(Arc)，用有序偶<vi,vj>来表示，vi称弧尾，vj称弧头；  
   有向图：                         有向边的图；  
- 简单图：不存在顶点到其自身的边，且同一条边不重复出现的图；  

- 无向完全图：在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图。n个顶点，n(n-1)/2条边；
- 有向完全图：在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图。n个顶点，n(n-1)条边；  

- 稀疏图：有很少条边或弧的图；反之稠密图；  
- 权(Weight)：与图的边或弧相关的数；  
- 网(Network)：带权的图；  

- 子图：  

### 图的顶点与边  
- 无向图：
    邻接
    依附
- 有向图：
    入度
    出度

- 连通图：
    连通分量
    强连通图
    强连通分量

- 生成树  
- 有向树
- 生成森林

## 图的抽象数据类型

```C
ADT Graph  
Data
    顶点的有穷非空集合和边的集合
Operation
    CreateGraph(*G, V, VR)  //按照顶点集V和边弧集VR的定义构造图G
    DestroyGraph(*G)    //图G存在则销毁
    LocateVex(G, u) //若图G中存在顶点u，则返回图中的位置
    GetVex(G,v) //返回图G中顶点v的值
    PutVex(G, v, value) //将图G中顶点v赋值value
    FirstAdjVex(G,*v)   //返回顶点v的第一个邻接顶点，若顶点在G中无邻接顶点返回空
    NextAdjVex(G, v, *w)    //返回顶点v相对于顶点w的下一个邻接顶点，若w是v的最后一个邻接点则返回空
    InsertVex(*G, v)    //在图中增添新顶点v
    DeleteVex(*G, v)    //删除图G中顶点v及其相关的弧
    InsertArc(*G, v, w) //在图中增添弧<v,w>，若G是无向图，还需要增添对称弧<w,v>
    DeleteArc(*G, v, w) //在图中删除弧<v,w>，若G是无向图，则还删除对称弧<w,v>
    DFSTraverse(G)  //对图G进行深度优先遍历， 在遍历过程中对每个顶点调用
    HFSTraverse(G)  //对图G进行广度优先便利，在遍历过程中对每个顶点调用
endADT  
```

## 图的存储结构  
- 邻接矩阵  
图的邻接矩阵(AdjacengyMatrix)存储方式是用两个数组来表示图。一个一维数组存数图中顶点信息，一个二维数组（称为邻接矩阵）存储图中的边或弧的信息。  
```C
/*
* 邻接矩阵代码实现
*/
[TODO]
```
- 邻接表  
对于边数相对于顶点较少的图，邻接矩阵存在储存空间的浪费。  
将数组与链表结合的存储方法称为邻接表；  
图中顶点用一个一维数组存储（或者由单链表存储）；对于顶点数组中，每个数据元素还需要存储指向第一个邻接点的指针，易于查找该顶点的边信息；  
图中每个顶点vi的所有邻接点构成一个线性表，由于邻接点的个数不定，所以用单链表存储，无向图称为顶点vi的边表，有向图则称为顶点vi作为弧尾的出边表。
```C
/*
* 邻接表代码实现
*/
[TODO]
```  
- 十字链表
[TODO]
- 邻接多重表
[TODO]
- 边集数组
边集数组是由两个一维数组组成。一个存储顶点信息，一个存储边的信息，这个边数组每个数据元素由一条边的起点下标(begin)、终点下标(end)和权(weight)组成。
[TODO]

### 图的遍历  
从图中某一个顶点出发访遍图中其余顶点，且使得每个顶点仅仅被访问一遍。  
- 深度优先遍历(DFS)
    对于连通图，从图中某个顶点v出发，访问此顶点，然后从v的未被访问的邻接点出发深度优先遍历图，直至图中所有和v有路径相通的顶点都被访问到；
    对于非连通图，只需要对他的连通分量分别进行深度优先遍历，即在先前一个顶点进行一次深度优先遍历后，若途中有顶点尚未被访问到，则另选图中一个未被访问的顶点作起始点，重复上述过程，直至途中所有顶点都被访问为止。
    ```C
    /*
    * 邻接矩阵的深度优先递归算法
    * /
    [TODO]
    ```
- 广度优先遍历(HFS)
    ```C
    / *
    * 邻接矩阵的广度遍历算法
    * /
    [TODO]
    ```

### 最小生成树  
构造连通网的最小代价生成树；
找连通网的最小生成树，两种经典方法：普里姆算法和克鲁斯卡尔算法
- 普里姆(Prim)算法
    ```C
    /*
    * Prim算法生成最小生成树
    * /
    [TODO]
    ```
- 克鲁斯卡尔(Kruskal)算法
    ```C
    /*
    * Kruskal算法生成最小生成树
    * /
    [TODO]
    ```

### 最短路径
对于网图，最短路径指两顶点之间经过的边上权值之和最少的路径，并且我们称路径上的第一个顶点是源点，最后一个顶点是终点。
两种求最短路径的算法：
- Dijkstra算法
[TODO]
- Floyd算法
[TODO]

### 拓扑排序
在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系，这样的有向图为顶点表示活动的网，称为AOV网(ActivityOnVertex)。  
设G=(V,E)是一个具有n个顶点的有向图，V中顶点序列v1,v2,...,vn，满足若从顶点vi到vj有一条路径，则在顶点序列中顶点vi必在顶点vj之前。我们称这样的顶点序列为一个拓扑序列。  
拓扑排序，就是对一个有向图构造拓扑序列的过程。

### 关键路径


## 查找  
根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素（或记录）。
查找表：由同一类型的数据元素（或记录）构成的集合。
关键字：数据元素中某个数据项的值。主关键字：此关键字可以唯一标识一个记录；次关键字：可以标识多个数据元素的关键字。  

查找表种类：静态查找表和动态查找表；
|---|---|---|
|种类|概念|主要操作|
|静态查找表|只作查找操作的查找表|1. 查询某个特定数据元素是否在查找表中；2. 检索某个特定数据元素和各种属性；|
|动态查找表|在查找过程中，同时插入查找表中不存在的数据元素，或从查找表中删除已经存在的某个数据元素|1. 查找时插入数据元素；2. 查找时删除数据元素；|

### 顺序查找（线性查找）：
```C
/*
* 顺序查找，a为数组，n为要查找的数组个数，key为要查找的关键字
*/
TODO
```

```C
/*
* 有哨兵的顺序查找，循环从数组尾部开始，返回0则说明查找失败；  
* 在查找方向尽头放置哨兵，避免每次比较后都要判断是否越界；
*/
TODO
```

### 有序表查找  
折半查找（二分查找）  
BinarySearch的前提是线性表中的记录必须是关键码有序（通常是由小到大），线性表必须采用顺序存储。  
```C
/*
* 折半查找
*/
TODO
```

插值查找

斐波那契查找
```C
/*
*斐波那契查找
*/
TODO
```

### 线性索引查找  
索引：把一个关键字与它对应的记录相关联的过程。
一个索引由若干个索引项构成，每个索引项至少应包含关键字和其对应的记录在存储器中的位置等信息，
按照结构分类：线性索引，树形索引和多级索引。
线性索引：将索引项集合组织为线性结构，也称索引表；重点介绍：稠密索引、分块索引和倒排索引。
- 稠密索引
指在线性索引中，将数据集中的每一个记录对应一个索引项；  
对于稠密索引的索引表来说，索引项一定是按照关键码有序的排列；  
对于有序的索引项，查找关键字能够使用折半、插值、斐波那契等有序查找算法，提高效率；但对于大数据集，查找性能下降；  
- 分块索引
对于分块有序的数据集，将每块对应一个索引项。
把数据集的记录分成若干块，并且块满足：1. 块内无序；2. 块间有序；
分块索引的索引项结构：1. 最大关键码：每一块中的最大关键字； 2. 块中记录的个数：便于循环时使用；3. 用于指向块首数据元素的指针：便于对该块记录进行遍历；  
在分块索引表中查找，两步：1. 在分块索引表中查找要查关键字所在块； 2. 根据块首指针找到相应的块，并在块中顺序查找关键码。  
- 倒排索引  
源于实际应用中需要根据属性的值来查找记录；
索引项的通用结构：
|---|---|
|次关键码|记录号表|
其中记录号表存储具有相同次关键字的所有记录的记录号（可以是指向记录的指针或者是该记录的主关键字）

### 二叉排序树  
动态
BinarySortTree，二叉查找树。它是一棵空树，或者具有以下性质的二叉树：1. 若他的左子树不空，则左子树上所有借点的值均小于他的根结点的值；2. 若它的右子树不空，则右子树上所有结点的值均大于他的根结点的值；3. 他的左右子树也分别为二叉排序树。  
```C
/*
* 二叉树的二叉链表结点结构定义
*/
TODO

/*
* 递归查找二叉排序树
* 递归查找二叉排序树T中是否存在key
* 指针f指向T的双亲，其初值调用为NULL
* 若查找成功，则指针p指向该数据元素结点，并返回TRUE
* 否则指针p指向查找路径上访问的最后一个结点并返回FALSE
*/
TODO

/*
* 二叉排序树插入操作
* 插入key并返回TRUE，否则返回FALSE
*/
TODO

/*
* 二叉排序树删除操作
* 若二叉排序树T中存在关键字等于key的数据元素时，则删除该数据元素结点，并返回TRUE；否则返回FALSE
*/
TODO
/*
* 二叉排序树中删除结点p，并重接他的左或右子树
*/
TODO


```

